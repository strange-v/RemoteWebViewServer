import sharp from "sharp";
import xxhash from "xxhash-wasm";
import type { Rect } from "./protocol";

export class FrameProcessor {
  public readonly width: number;
  public readonly height: number;
  public readonly tile: number;

  private _h32!: (buf: ArrayBufferView | ArrayBuffer, seed?: number) => number;
  private _prevFrameHash: number = 0;
  private _prevHashes: Uint32Array;
  private _cols: number;
  private _rows: number;

  constructor(width: number, height: number, tile: number) {
    this.width = width;
    this.height = height;
    this.tile = tile;
    this._cols = Math.ceil(width / tile);
    this._rows = Math.ceil(height / tile);
    this._prevHashes = new Uint32Array(this._cols * this._rows);
  }

  async initAsync(): Promise<void> {
    const { h32Raw } = await xxhash();
    this._h32 = (buf, seed = 0xc0ffee) => h32Raw(buf as any, seed >>> 0);
  }

  async processPngFrameAsync(pngFull: Buffer): Promise<Rect[]> {
    const changed: Rect[] = [];

    const frameHhash = this._h32(pngFull);
    if (this._prevFrameHash == frameHhash) return changed;
    this._prevFrameHash = frameHhash;

    const { data: rgba } = await sharp(pngFull).raw().ensureAlpha().toBuffer({ resolveWithObject: true });

    for (let ty = 0; ty < this._rows; ty++) {
      for (let tx = 0; tx < this._cols; tx++) {
        const x = tx * this.tile;
        const y = ty * this.tile;
        const w = Math.min(this.tile, this.width - x);
        const h = Math.min(this.tile, this.height - y);
        if (w <= 0 || h <= 0) continue;

        // Slice tile rows into tmp buffer for hashing.
        const tileBuf = Buffer.allocUnsafe(w * h * 4);
        for (let yy = 0; yy < h; yy++) {
          const src = ((y + yy) * this.width + x) * 4;
          rgba.copy(tileBuf, yy * w * 4, src, src + w * 4);
        }

        const idx = ty * this._cols + tx;
        const hash = this._h32(tileBuf);
        if (this._prevHashes[idx] !== hash) {
          // Re-encode changed tile as PNG.
          const tilePng = await sharp(tileBuf, { raw: { width: w, height: h, channels: 4 } })
            .png({ compressionLevel: 9 })
            .toBuffer();
          changed.push({ x, y, w, h, data: tilePng });
          this._prevHashes[idx] = hash;
        }
      }
    }
    return changed;
  }
}
